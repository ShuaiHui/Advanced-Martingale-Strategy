// © N
// 本源代码受Mozilla Public License 2.0条款的约束，详见https://mozilla.org/MPL/2.0/
// @version=5

strategy("Martingale Strategy [Alerts]", 
   overlay=true, // 在图表上显示策略
   max_labels_count = 500, // 标签数量的最大值
   pyramiding = 10, // 设置金字塔式加仓的最大次数
   default_qty_type = strategy.cash, // 设置默认交易量类型为现金值
   initial_capital = 1000, // 初始资本设置为1000
   commission_type = strategy.commission.percent, // 设置佣金类型为百分比
   commission_value = 0.2, // 佣金值设置为0.2%
   default_qty_value = 100 // 默认的交易量值设置为100
   )

//--- 色彩定义 ---
color blue = color.rgb(23, 43, 77)

//--- 输入设置 ---
string s_group = " Strategy Settings"
string visual = "Visual Settings"
var int glb_dealstart_bar_time = 0
int Length = 14
float ChangePercentage = input.float(title='SRP %', defval=1.4, group='SRP Settings', inline="00", step=0.1)
float core = ta.vwma(hlc3, Length)
float below = input(56, title="⬇️", group='SRP Settings', inline="00")
float above = input(100, title="⬆️", group='SRP Settings', inline="00")
bool mintpbool = input.bool(true, "Minimal TP %", group=s_group, inline="01")
float mintp = input.float(2.0, "", step=0.1, group=s_group, inline="01")/100
float minSOchange = input.float(title='Price change %', defval=2.0, step=0.1, group=s_group, inline="01")
float base = input.float(title='$ Base order', defval=100, step=10, group=s_group, inline="01")
float safety = input.float(title='DCA Multi', defval=1.5, step=0.1, group=s_group, inline="01")
int max_dca_count = input.int(title='DCA Count', defval=5, step=1, group=s_group, inline="01")

int sonum = max_dca_count + 1
bool DCATYPE = input.string("Volume Multiply", title="DCA TYPE", options=["Volume Multiply", "Base Multiply"], group=s_group, inline="01") == "Volume Multiply"


var float priceDropPercentage = input.float(title='Price Drop %', defval=2, step=0.2, group=s_group, inline="01") / 100
float priceDropMultiplier = input.float(title='Drop Multiplier', defval=1, step=0.1, group=s_group, inline="01")

isPriceDropConditionMet() =>
    (close / strategy.position_avg_price - 1) <= -priceDropPercentage

// --- 开仓警报开关 ---
bool alertOnOpen = input.bool(false, title="Alert On Deal Open", group="DIY Settings", inline="00")

dcaIntervalMinutes = input.int(title="DCA Interval (min)", defval=30, step=30, minval=0, group="DIY Settings", inline="01")
var int lastOrderTime = na

float maxWaitDays = input.float(title="Max Wait Time (days)", defval=7, step=1, minval=0, group="DIY Settings", inline="01")
isTimeExceeded() =>
    na(lastOrderTime) ? false : (time - lastOrderTime) > maxWaitDays * 86400000 

int alert_dca_threshold = input.int(title="Alert After DCA", defval=1, step=1, minval=0, group="DIY Settings", inline="02") 

//--- 可视化设置 ---
bool showdeals = input(true, "Deal lines", inline="001", group=visual)
color profitcolor = input.color(color.new(color.teal, 85), "Profit Fill", inline="002", group=visual)
color socolor = input.color(color.new(color.maroon, 85), "SO Fill", inline="002", group=visual)
color avgcolor = input.color(color.white, "AVG Line", inline="002", group=visual)
bool showBG = input(false, "Deal BG Color", inline="003", group=visual)
color bgcolor = input.color(blue, "", inline="003", group=visual)
bool showpnllabel = input.bool(false, "PNL Label", inline="003", group=visual)
color pnlcolor = input.color(color.new(color.green, 20), "", inline="003", group=visual)
bool showDebugLabels = input.bool(true, "Alert Debug Labels", inline="004", group=visual)


isTimeIntervalPassed() =>
    na(lastOrderTime) or (time - lastOrderTime) >= dcaIntervalMinutes * 60 * 1000

//--- 变量和函数 ---
var int socounter = 0
var int dealcount = 0
var int finalDcaCounter = 0
// 用于存储每个DCA级别历史触发次数的数组
var dca_trigger_counts = array.new_int(max_dca_count + 1, 0)

vwma_above = core * (1 + (ChangePercentage / 100))
vwma_below = core * (1 - (ChangePercentage / 100))

up = ta.rma(math.max(ta.change(close), 0), 7)
down = ta.rma(-math.min(ta.change(close), 0), 7)
rsi = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))
mf = ta.mfi(hlc3, 7)
rsi_mfi = math.abs(rsi + mf / 2)

long = low <= vwma_below and (rsi_mfi < below)
short = high >= vwma_above and (rsi_mfi > above)

calcNextSOprice(pcnt) =>
    if strategy.position_size > 0
        strategy.position_avg_price - (math.round(pcnt / 100 * strategy.position_avg_price / syminfo.mintick)) * syminfo.mintick
    else if strategy.position_size < 0
        strategy.position_avg_price + (math.round(pcnt / 100 * strategy.position_avg_price / syminfo.mintick)) * syminfo.mintick
    else
        na

calcChnagefromlastdeal() =>
    last_deal = strategy.opentrades.entry_price(strategy.opentrades - 1)
    math.abs(((close - (last_deal)) / close) * 100)

Calcprofitpercent() =>
    math.abs(((close - strategy.position_avg_price) / close) * 100)

SO = base * safety
CapitalCalculation() =>
    float total = 0.0
    for x = 1 to sonum - 1 by 1
        so_size = SO * math.pow(safety, x - 1)
        total += so_size
    total + base

calculateSO(num) =>
    SOv = base * math.pow(safety, num)
    SOv

SOconditions() =>
    (calcChnagefromlastdeal() > minSOchange * math.pow(priceDropMultiplier, socounter)) and (close < calcNextSOprice(minSOchange * math.pow(priceDropMultiplier, socounter)))

mintpclogic() =>
   (close > (strategy.position_avg_price * (1 + mintp)))

get_timestring_from_seconds(seconds) =>
    if seconds >= 86400
        string _string = str.tostring(math.round(seconds / 86400, 1)) + ' days'
    else if seconds >= 3600
        string _string = str.tostring(math.round(seconds / 3600, 1)) + ' hours'
    else
        string _string = str.tostring(math.round(seconds / 60, 1)) + ' mins'

get_timespan_string(start_time, end_time) =>
    _seconds_diff = (end_time - start_time) / 1000
    get_timestring_from_seconds(_seconds_diff)

Calcprofit() =>
    ((close * strategy.position_size) - (strategy.position_avg_price * strategy.position_size))

PNLlabel(labelColor) =>
    message = ""
    message += "PNL :  " + str.tostring(math.round(Calcprofit(), 2)) + '  ' + str.tostring(syminfo.currency) + '\n'
    message += "Time:  " + get_timespan_string(glb_dealstart_bar_time, time) + '\n'
    message += "PNL%:  " + str.tostring(math.round(Calcprofitpercent(), 2)) + " %"
    topy = high + (high * 0.04)
    label.new(bar_index + 1, topy, text=message, yloc=yloc.price, size=size.normal, style=label.style_label_lower_left, textcolor=color.black, textalign=text.align_left, color=labelColor)

Opentrade() =>
    strategy.opentrades > 0 ? 1 : 0

PNLpercentage() =>
    ((close - strategy.position_avg_price) / close) * 100

//--------------------------------------------------------------------------
//                        # Strategy Logic #
//--------------------------------------------------------------------------

if (long and isTimeIntervalPassed()) and strategy.opentrades == 0
    socounter := 0
    dealcount += 1
    glb_dealstart_bar_time := time
    strategy.entry("LONG", strategy.long, comment="D # " + str.tostring(dealcount), qty=base / close)
    lastOrderTime := time
    
// 通过检测仓位状态从0到大于0的变化来精确触发警报
bool newDealOpened = strategy.opentrades > 0 and strategy.opentrades[1] == 0

if alertOnOpen and newDealOpened
    string open_alert_message = "DEAL Open for " + syminfo.tickerid
    alert(open_alert_message, freq=alert.freq_once_per_bar)


// DCA加仓逻辑
if (long and SOconditions() and isTimeIntervalPassed() and isPriceDropConditionMet()) and strategy.opentrades > 0 and strategy.opentrades < sonum
    socounter += 1
    strategy.entry('LONG', strategy.long, qty=DCATYPE ? (strategy.position_size * safety) : calculateSO(socounter) / close, comment="SO # " + str.tostring(socounter))
    
    // --- 警报逻辑 ---
    // 只有当DCA次数大于设定的阈值时，才触发警报
    if socounter > alert_dca_threshold
        // 创建包含交易所和商品名称的警报消息
        string alert_message = "DCA #" + str.tostring(socounter) + " for " + syminfo.tickerid
        if socounter == max_dca_count
            // 最终DCA的警报消息
            alert_message := "FINAL DCA (#" + str.tostring(socounter) + ") for " + syminfo.tickerid
            finalDcaCounter += 1 

        // 调用alert()函数
        alert(alert_message, freq=alert.freq_once_per_bar_close)

        // 更新并显示历史触发次数的调试标签
        if showDebugLabels
            // 获取当前DCA级别的历史触发次数
            int current_trigger_count = array.get(dca_trigger_counts, socounter)
            // 将次数加一
            int new_trigger_count = current_trigger_count + 1
            // 将新的次数存回数组
            array.set(dca_trigger_counts, socounter, new_trigger_count)
            // 创建标签文本，显示历史总次数
            string label_text = "DCA " + str.tostring(socounter) + " Trigger Count: " + str.tostring(new_trigger_count)
            label.new(bar_index, na, label_text, yloc=yloc.abovebar, color=color.new(color.orange, 25), textcolor=color.black, style=label.style_label_down)

    lastOrderTime := time

// --- 整合后的平仓逻辑 ---
if (strategy.position_size > 0)
    
    // 定义平仓原因
    string close_reason = ""

    // 检查平仓条件
    bool close_by_timeout = isTimeExceeded()
    bool close_by_takeprofit = short and (mintpbool ? mintpclogic() : true)

    if (close_by_timeout)
        close_reason := "Max Wait Time after " + str.tostring(socounter) + " DCAs"
        strategy.close("LONG", comment="Auto Close: Max Wait Time Exceeded")
        
    else if (close_by_takeprofit)
        close_reason := "Take Profit after " + str.tostring(socounter) + " DCAs"
        strategy.close("LONG", comment=" ")

    // 如果触发了任一平仓条件
    if (close_by_timeout or close_by_takeprofit)
        
        // 检查是否需要发送警报
        if (socounter > alert_dca_threshold) or (alertOnOpen and socounter == 0)
            // 平仓的警报消息
            string alert_message = "DEAL Close for " + syminfo.tickerid + " (Reason: " + close_reason + ")"
            alert(alert_message, freq=alert.freq_once_per_bar_close)
        
        // 显示PNL标签
        if (showpnllabel)
            PNLlabel(close_by_timeout ? color.red : color.green)


//--------------------------------------------------------------------------
//                                # Plotting #
//--------------------------------------------------------------------------

avg = plot(showdeals? strategy.position_avg_price : na, 'AVG Price',color= avgcolor, style=plot.style_linebr,editable = false)
sl = plot(showdeals ? calcNextSOprice(minSOchange): na, 'SO change %', color.orange, style=plot.style_linebr,editable = false)   
tp = plot(showdeals ? strategy.position_avg_price * (1 + mintp): na, 'SO change %', color.rgb(3, 233, 245), style=plot.style_linebr,editable = false)    
   
fill(tp, avg, color =profitcolor)
fill(avg, sl, color = socolor)
bgcolor(showBG and strategy.position_size > 0 ? color.new(bgcolor,90): na)   

statusOpen()=>
    Opentrade() == 0 ? str.tostring(Opentrade()) : str.tostring(Opentrade()) + "\n" + "------" + "\n" +  str.tostring(syminfo.currency) + " :" + "$" + str.tostring(math.round(strategy.openprofit,2))+ "\n" 
         + "------" + "\n" + "% " + " :" + str.tostring(math.round(PNLpercentage(),2))+ " %"